
abstract iGame
    Variables:

    Methods:
        virtual void Draw() = 0;
        virtual void Logic() = 0;
        virtual void Update() = 0;
        virtual void CheckCollisions() = 0;
        virtual void Cycle() = 0;

Game : public iGame
    Variables:
        GameState* _gameState
        sf::RenderWindow window
    Methods:
        Game()
        ~Game()
        void LoadGameState(GameState gameState)
        void CheckStateChange(GameState)

GameProxy
    Variables:
        Game* game
    Methods:
        GameProxy(const Game * game)
        void LoadGameState(GameState gameState)
        sf:RenderWindow& GetWindowRef()

GameState : public iGame
    Variables:
        GameProxy* gameProxy
        Input* input
        std::vector<GameObjects*> gameObjects
    Methods:
        GameState(const GameProxy * proxy)
        virtual ~GameState()
        AddGameObject(GameObject* gameObj)
        AddInputHandler(Input* input)
        virtual ~GameState()
        void HandleDeactivatedObjects()

MainGame : public GameState
    Variables:
        bool gameHasStarted
    Methods:
        MainGame()
        ~MainGame()
        void StartGame()
        void ResetPlayerAndBall()

Input
    Variables:
        std::vector<Command*> commands
    Methods:
        Input()
        ~Input()
        AddCommand(Command* command)
        HandleInput()

abstract Command
    Variables:
        GameObject* gameObj
    Methods:
        virtual Command(const GameObject * gameObj)
        virtual ~Command()
        virtual void Execute() = 0;
        virtual bool CheckCondition() = 0;

MoveLeftCommand : Command
    Variables:
        
    Methods:
        LeftCommand(const Player * player)
        ~LeftCommand()
        void Execute() override
        bool CheckCondition() override // use sf::Keyboard::isKeyPressed(sf::Keyboard::Left)

MoveRightCommand : Command
    Variables:
        
    Methods:
        RightCommand(const Player * player)
        ~RightCommand()
        void Execute() override
        bool CheckCondition() override // use sf::Keyboard::isKeyPressed(sf::Keyboard::Right)

MovePlayerOnMouseCommand : Command
    Variables:
        sf::Vector2i position
    Methods:
        MovePlayerOnMouseCommand(const Player * player)
        ~MovePlayerOnMouseCommand()
        void Execute() override
        bool CheckCondition() override // sf::Mouse::getPosition() to check if mouse is in updated position, and set sf::Vector2i "position" variable

StartGameCommand : Command
    Variables:
        
    Methods:
        StartGameCommand(const MainGame * mainGame)
        ~StartGameCommand()
        void Execute() override
        bool CheckCondition() override // use sf::Mouse::isButtonPressed(sf::Mouse::Left)


abstract GameObject
    Variables:
        Vector2f position
        bool isActive // will be true by default
    Methods:
        GameObject(const Vector2f& Position)
        virtual ~GameObject
        Vector2f GetPosition()
        bool GetIsActive()
        void Deactivate() // set isActive boolean to false;
        virtual void Draw(sf::RenderWindow& window) = 0; // pure virtual
        virtual void Update() = 0; // pure virtual

abstract Collidable : public GameObject
    Variables:
        sf::Shape* shape
    Methods:
        Collidable(const Vector2f& Position)
        virtual ~Collidable() // need a destructor so that we can be sure the collisionObj pointer gets deleted from memory
        const Shape * GetShapeObject() // returns the Shape pointer. NOTE I don't know if I have the constant keyword placed correctly
        virtual void Draw(sf::RenderWindow& window)

abstract Moveable : public GameObject
    Variables:
        Vector2f Velocity
        float speed;
    Methods:
        virtual void SetSpeed(const float& newSpeed)
        virtual void SetVelocity(const Vector2f& u_Direction) // take in a direction unit vector, scale by the speed, then assign to Velocity
        virtual void UpdatePosition(const Vector2f& newPosition)
        virtual void Update(); // add the velocity to the position vector. Keep this method virtual to allow children to override if needed.

Wall : public GameObject
    Variables:
        // need to make a sf::RectangleShape object in constructor and assign that to *shape
    Methods:
        Wall(const Vector2f& Position, const unsigned& Width, const unsigned& Height, sf::Color color)
        ~Wall()
        Draw(sf::RenderWindow& window) override

Brick : public GameObject
    Variables:
        // need to make a sf::RectangleShape object in constructor and assign that to *shape
    Methods:
        Brick(const Vector2f& Position, const unsigned& Width, const unsigned& Height, sf::Color& color)
        ~Brick()
        Draw(sf::RenderWindow& window) override


Paddle : public Moveable
    Variables:
        // need to make a sf::RectangleShape object in constructor and assign that to *shape
    Methods:
        Paddle(const Vector2f& Position, const unsigned& Width, const unsigned& Height, sf::Color& color)
        ~Paddle()
        Draw(sf::RenderWindow& window) override
        Update() override
    
Ball : public Moveable
    Variables:
        // need to make a sf::CircleShape object in constructor and assign that to *shape
    Methods:
        Ball(const Vector2f& Position, const unsigned& Radius, const sf::Color& color)
        ~Ball()
        Draw(sf::RenderWindow& window) override
        Update() override

Player : public Moveable
    Variables:
        unsigned lives
        Paddle paddle
        unsigned score
    Methods:
        void DecrementLife()
        unsigned GetLives()
        unsigned GetScore()

GameText : Public GameObject
    Variables:
       sf::Text text
    Methods:
        GameText(string fontFileName, bool Bold, unsigned Size, sf::Color color)
        ~GameText()

ScoreText : Public GameText
    Variables:
       Player *player
    Methods:
        ScoreText(const Player * player)

LivesText : Public GameText
    Variables:
       Player *player
    Methods:
        LivesText(const Player * player)


//////////////////////////////////////////////////////////////////////////////////////////
// circle and rectangle collision
bool intersects(const sf::CircleShape &c, const sf::RectangleShape &r){
    sf::FloatRect fr = r.getGlobalBounds();
    sf::Vector2f topLeft(fr.left, fr.top);
    sf::Vector2f topRight(fr.left + fr.width, fr.top);
    sf::Vector2f botLeft(fr.left, fr.top + fr.height);
    sf::Vector2f botRight(fr.left + fr.width, fr.top + fr.height);

    return contains(c, topLeft) || 
        contains(c, topRight) || 
        contains(c, botLeft) || 
        contains(c, botRight);
}

bool contains(const sf::CircleShape &c, const sf::Vector2f &p){
    sf::Vector2f center = c.getPosition();
    float a = (p.x - center.x);
    float b = (p.y - center.y);
    a *= a;
    b *= b;
    float r = c.getRadius() * c.getRadius();

    return (( a + b ) < r);
}

// can use this for rectangle on rectangle collision
if (shape.getGlobalBounds().intersects(shape2.getGlobalBounds()))
        {
            int nop = 0;
        }